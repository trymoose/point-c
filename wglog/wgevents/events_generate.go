// Code generated by events-generate; DO NOT EDIT.
package wgevents

import (
	"fmt"
	"golang.zx2c4.com/wireguard/device"
	"golang.zx2c4.com/wireguard/tai64n"
	"log/slog"
)

var parser Parser

type Parser interface {
	ParseUDPGSODisabled(*EventUDPGSODisabled, string, ...any) bool
}

// Errorf formats
var _ = map[string]struct{}{
	"Trouble determining MTU, assuming default: %v":  {},
	"Bind close failed: %v":                          {},
	"Failed to create cookie reply: %v":              {},
	"%v - Failed to create initiation message: %v":   {},
	"%v - Failed to create response message: %v":     {},
	"%v - Failed to derive keypair: %v":              {},
	"%v - Failed to send handshake response: %v":     {},
	"Failed to decode initiation message":            {},
	"invalid UAPI operation: %v":                     {},
	"Invalid packet ended up in the handshake queue": {},
	"Failed to load updated MTU of device: %v":       {},
	"MTU not updated to negative value: %v":          {},
	"%v - Failed to send data packets: %v":           {},
	"Failed to decode response message":              {},
	"%v - Failed to send handshake initiation: %v":   {},
	"Failed to write packets to TUN device: %v":      {},
	"Failed to read packet from TUN device: %v":      {},
	"Unable to update bind: %v":                      {},
	"%v":                                             {},
}

// Verbosef formats
var _ = map[string]struct{}{
	"UDP bind has been updated":                                                 {},
	"Could not decrypt invalid cookie response":                                 {},
	"Failed to decode cookie reply":                                             {},
	"Routine: decryption worker %d - stopped":                                   {},
	"Device closed":                                                             {},
	"Device closing":                                                            {},
	"Dropped some packets from multi-segment read: %v":                          {},
	"Routine: event worker - started":                                           {},
	"Routine: event worker - stopped":                                           {},
	"%s - Handshake did not complete after %d attempts, giving up":              {},
	"%v - ConsumeMessageInitiation: handshake flood":                            {},
	"%v - ConsumeMessageInitiation: handshake replay @ %v":                      {},
	"IPv4 packet with disallowed source address from %v":                        {},
	"IPv6 packet with disallowed source address from %v":                        {},
	"Interface closed, ignored requested state %s":                              {},
	"Interface down requested":                                                  {},
	"Interface state was %s, requested %s, now %s":                              {},
	"Interface up requested":                                                    {},
	"Received packet with invalid mac1":                                         {},
	"MTU updated: %v (too large, capped at %v)":                                 {},
	"MTU updated: %v":                                                           {},
	"Received message with unknown type":                                        {},
	"Packet with invalid IP version from %v":                                    {},
	"Received packet with unknown IP version":                                   {},
	"Failed to receive %s packet: %v":                                           {},
	"%v - Starting":                                                             {},
	"%v - Stopping":                                                             {},
	"%v - Received handshake initiation":                                        {},
	"%v - Received handshake response":                                          {},
	"Received invalid initiation message from %s":                               {},
	"Received invalid response message from %s":                                 {},
	"Receiving cookie response from %s":                                         {},
	"%v - Receiving keepalive packet":                                           {},
	"%s - Removing all keys, since we haven't received a new one in %d seconds": {},
	"%s - Handshake did not complete after %d seconds, retrying (try %d)":       {},
	"%s - Retrying handshake because we stopped hearing back after %d seconds":  {},
	"Sending cookie response for denied handshake message for %v":               {},
	"%v - Sending handshake initiation":                                         {},
	"%v - Sending handshake response":                                           {},
	"%v - Sending keepalive packet":                                             {},
	"%v - Routine: sequential sender - stopped":                                 {},
	"%v - Routine: sequential receiver - started":                               {},
	"%v - Routine: sequential receiver - stopped":                               {},
	"%v - Routine: sequential sender - started":                                 {},
	"Routine: decryption worker %d - started":                                   {},
	"Routine: encryption worker %d - started":                                   {},
	"Routine: handshake worker %d - started":                                    {},
	"Routine: receive incoming %s - stopped":                                    {},
	"Routine: encryption worker %d - stopped":                                   {},
	"Routine: handshake worker %d - stopped":                                    {},
	"Routine: receive incoming %s - started":                                    {},
	"Routine: TUN reader - started":                                             {},
	"Routine: TUN reader - stopped":                                             {},
	"%v - UAPI: Adding allowedip":                                               {},
	"%v - UAPI: Created":                                                        {},
	"%v - UAPI: Removing all allowedips":                                        {},
	"UAPI: Removing all peers":                                                  {},
	"%v - UAPI: Removing":                                                       {},
	"%v - UAPI: Updating endpoint":                                              {},
	"UAPI: Updating fwmark":                                                     {},
	"UAPI: Updating listen port":                                                {},
	"%v - UAPI: Updating persistent keepalive interval":                         {},
	"%v - UAPI: Updating preshared key":                                         {},
	"UAPI: Updating private key":                                                {},
	"disabled UDP GSO on %s, NIC(s) may not support checksum offload":           {},
}

type Event interface {
	Nice() string
	Format() string
	Args() []any
	Slog(*slog.Logger)
	IsErrorf() bool
}

var _ Event = (*EventAssumingDefaultMTU)(nil)

type EventAssumingDefaultMTU struct {
	Err error
}

func (e *EventAssumingDefaultMTU) IsErrorf() bool { return true }
func (*EventAssumingDefaultMTU) Format() string {
	return "Trouble determining MTU, assuming default: %v"
}
func (e *EventAssumingDefaultMTU) Args() []any         { return []any{e.Err} }
func (*EventAssumingDefaultMTU) Nice() string          { return "Trouble determining MTU, assuming default" }
func (e *EventAssumingDefaultMTU) Slog(l *slog.Logger) { l.Error(e.Nice(), "Err", e.Err) }

var _ Event = (*EventBindCloseFailed)(nil)

type EventBindCloseFailed struct {
	Err error
}

func (e *EventBindCloseFailed) IsErrorf() bool      { return true }
func (*EventBindCloseFailed) Format() string        { return "Bind close failed: %v" }
func (e *EventBindCloseFailed) Args() []any         { return []any{e.Err} }
func (*EventBindCloseFailed) Nice() string          { return "Bind close failed" }
func (e *EventBindCloseFailed) Slog(l *slog.Logger) { l.Error(e.Nice(), "Err", e.Err) }

var _ Event = (*EventBindUpdated)(nil)

type EventBindUpdated struct{}

func (e *EventBindUpdated) IsErrorf() bool      { return false }
func (*EventBindUpdated) Format() string        { return "UDP bind has been updated" }
func (e *EventBindUpdated) Args() []any         { return []any{} }
func (*EventBindUpdated) Nice() string          { return "" }
func (e *EventBindUpdated) Slog(l *slog.Logger) { l.Info(e.Nice()) }

var _ Event = (*EventCookieResponseInvalid)(nil)

type EventCookieResponseInvalid struct{}

func (e *EventCookieResponseInvalid) IsErrorf() bool { return false }
func (*EventCookieResponseInvalid) Format() string {
	return "Could not decrypt invalid cookie response"
}
func (e *EventCookieResponseInvalid) Args() []any         { return []any{} }
func (*EventCookieResponseInvalid) Nice() string          { return "" }
func (e *EventCookieResponseInvalid) Slog(l *slog.Logger) { l.Warn(e.Nice()) }

var _ Event = (*EventCreateCookieReplyFailed)(nil)

type EventCreateCookieReplyFailed struct {
	Err error
}

func (e *EventCreateCookieReplyFailed) IsErrorf() bool      { return true }
func (*EventCreateCookieReplyFailed) Format() string        { return "Failed to create cookie reply: %v" }
func (e *EventCreateCookieReplyFailed) Args() []any         { return []any{e.Err} }
func (*EventCreateCookieReplyFailed) Nice() string          { return "Failed to create cookie reply" }
func (e *EventCreateCookieReplyFailed) Slog(l *slog.Logger) { l.Error(e.Nice(), "Err", e.Err) }

var _ Event = (*EventCreateInitiationMessageFailed)(nil)

type EventCreateInitiationMessageFailed struct {
	Peer *device.Peer
	Err  error
}

func (e *EventCreateInitiationMessageFailed) IsErrorf() bool { return true }
func (*EventCreateInitiationMessageFailed) Format() string {
	return "%v - Failed to create initiation message: %v"
}
func (e *EventCreateInitiationMessageFailed) Args() []any { return []any{e.Peer, e.Err} }
func (*EventCreateInitiationMessageFailed) Nice() string {
	return "Failed to create initiation message"
}
func (e *EventCreateInitiationMessageFailed) Slog(l *slog.Logger) {
	l.Error(e.Nice(), "Peer", e.Peer, "Err", e.Err)
}

var _ Event = (*EventCreateResponseMessageFailed)(nil)

type EventCreateResponseMessageFailed struct {
	Peer *device.Peer
	Err  error
}

func (e *EventCreateResponseMessageFailed) IsErrorf() bool { return true }
func (*EventCreateResponseMessageFailed) Format() string {
	return "%v - Failed to create response message: %v"
}
func (e *EventCreateResponseMessageFailed) Args() []any { return []any{e.Peer, e.Err} }
func (*EventCreateResponseMessageFailed) Nice() string  { return "Failed to create response message" }
func (e *EventCreateResponseMessageFailed) Slog(l *slog.Logger) {
	l.Error(e.Nice(), "Peer", e.Peer, "Err", e.Err)
}

var _ Event = (*EventDecodeCookieReplyFailed)(nil)

type EventDecodeCookieReplyFailed struct{}

func (e *EventDecodeCookieReplyFailed) IsErrorf() bool      { return false }
func (*EventDecodeCookieReplyFailed) Format() string        { return "Failed to decode cookie reply" }
func (e *EventDecodeCookieReplyFailed) Args() []any         { return []any{} }
func (*EventDecodeCookieReplyFailed) Nice() string          { return "" }
func (e *EventDecodeCookieReplyFailed) Slog(l *slog.Logger) { l.Warn(e.Nice()) }

var _ Event = (*EventDecryptionWorkerStopped)(nil)

type EventDecryptionWorkerStopped struct {
	ID int
}

func (e *EventDecryptionWorkerStopped) IsErrorf() bool { return false }
func (*EventDecryptionWorkerStopped) Format() string {
	return "Routine: decryption worker %d - stopped"
}
func (e *EventDecryptionWorkerStopped) Args() []any         { return []any{e.ID} }
func (*EventDecryptionWorkerStopped) Nice() string          { return "Routine: decryption worker stopped" }
func (e *EventDecryptionWorkerStopped) Slog(l *slog.Logger) { l.Debug(e.Nice(), "ID", e.ID) }

var _ Event = (*EventDeriveKeypairFailed)(nil)

type EventDeriveKeypairFailed struct {
	Peer *device.Peer
	Err  error
}

func (e *EventDeriveKeypairFailed) IsErrorf() bool { return true }
func (*EventDeriveKeypairFailed) Format() string   { return "%v - Failed to derive keypair: %v" }
func (e *EventDeriveKeypairFailed) Args() []any    { return []any{e.Peer, e.Err} }
func (*EventDeriveKeypairFailed) Nice() string     { return "Failed to derive keypair" }
func (e *EventDeriveKeypairFailed) Slog(l *slog.Logger) {
	l.Error(e.Nice(), "Peer", e.Peer, "Err", e.Err)
}

var _ Event = (*EventDeviceClosed)(nil)

type EventDeviceClosed struct{}

func (e *EventDeviceClosed) IsErrorf() bool      { return false }
func (*EventDeviceClosed) Format() string        { return "Device closed" }
func (e *EventDeviceClosed) Args() []any         { return []any{} }
func (*EventDeviceClosed) Nice() string          { return "" }
func (e *EventDeviceClosed) Slog(l *slog.Logger) { l.Debug(e.Nice()) }

var _ Event = (*EventDeviceClosing)(nil)

type EventDeviceClosing struct{}

func (e *EventDeviceClosing) IsErrorf() bool      { return false }
func (*EventDeviceClosing) Format() string        { return "Device closing" }
func (e *EventDeviceClosing) Args() []any         { return []any{} }
func (*EventDeviceClosing) Nice() string          { return "" }
func (e *EventDeviceClosing) Slog(l *slog.Logger) { l.Debug(e.Nice()) }

var _ Event = (*EventDroppedPacketsFromMultiSegmentRead)(nil)

type EventDroppedPacketsFromMultiSegmentRead struct {
	Err error
}

func (e *EventDroppedPacketsFromMultiSegmentRead) IsErrorf() bool { return false }
func (*EventDroppedPacketsFromMultiSegmentRead) Format() string {
	return "Dropped some packets from multi-segment read: %v"
}
func (e *EventDroppedPacketsFromMultiSegmentRead) Args() []any { return []any{e.Err} }
func (*EventDroppedPacketsFromMultiSegmentRead) Nice() string {
	return "Dropped some packets from multi-segment read"
}
func (e *EventDroppedPacketsFromMultiSegmentRead) Slog(l *slog.Logger) {
	l.Error(e.Nice(), "Err", e.Err)
}

var _ Event = (*EventEventWorkerStarted)(nil)

type EventEventWorkerStarted struct{}

func (e *EventEventWorkerStarted) IsErrorf() bool      { return false }
func (*EventEventWorkerStarted) Format() string        { return "Routine: event worker - started" }
func (e *EventEventWorkerStarted) Args() []any         { return []any{} }
func (*EventEventWorkerStarted) Nice() string          { return "" }
func (e *EventEventWorkerStarted) Slog(l *slog.Logger) { l.Debug(e.Nice()) }

var _ Event = (*EventEventWorkerStopped)(nil)

type EventEventWorkerStopped struct{}

func (e *EventEventWorkerStopped) IsErrorf() bool      { return false }
func (*EventEventWorkerStopped) Format() string        { return "Routine: event worker - stopped" }
func (e *EventEventWorkerStopped) Args() []any         { return []any{} }
func (*EventEventWorkerStopped) Nice() string          { return "" }
func (e *EventEventWorkerStopped) Slog(l *slog.Logger) { l.Debug(e.Nice()) }

var _ Event = (*EventHandshakeDidNotComplete)(nil)

type EventHandshakeDidNotComplete struct {
	Peer     *device.Peer
	Attempts int
}

func (e *EventHandshakeDidNotComplete) IsErrorf() bool { return false }
func (*EventHandshakeDidNotComplete) Format() string {
	return "%s - Handshake did not complete after %d attempts, giving up"
}
func (e *EventHandshakeDidNotComplete) Args() []any { return []any{e.Peer, e.Attempts} }
func (*EventHandshakeDidNotComplete) Nice() string  { return "Handshake did not complete, giving up" }
func (e *EventHandshakeDidNotComplete) Slog(l *slog.Logger) {
	l.Info(e.Nice(), "Peer", e.Peer, "Attempts", e.Attempts)
}

var _ Event = (*EventHandshakeFlood)(nil)

type EventHandshakeFlood struct {
	Peer *device.Peer
}

func (e *EventHandshakeFlood) IsErrorf() bool      { return false }
func (*EventHandshakeFlood) Format() string        { return "%v - ConsumeMessageInitiation: handshake flood" }
func (e *EventHandshakeFlood) Args() []any         { return []any{e.Peer} }
func (*EventHandshakeFlood) Nice() string          { return "ConsumeMessageInitiation: handshake flood" }
func (e *EventHandshakeFlood) Slog(l *slog.Logger) { l.Warn(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventHandshakeReplay)(nil)

type EventHandshakeReplay struct {
	Peer      *device.Peer
	Timestamp tai64n.Timestamp
}

func (e *EventHandshakeReplay) IsErrorf() bool { return false }
func (*EventHandshakeReplay) Format() string {
	return "%v - ConsumeMessageInitiation: handshake replay @ %v"
}
func (e *EventHandshakeReplay) Args() []any { return []any{e.Peer, e.Timestamp} }
func (*EventHandshakeReplay) Nice() string  { return "ConsumeMessageInitiation: handshake replay" }
func (e *EventHandshakeReplay) Slog(l *slog.Logger) {
	l.Warn(e.Nice(), "Peer", e.Peer, "Timestamp", e.Timestamp)
}

var _ Event = (*EventHandshakeSendFailed)(nil)

type EventHandshakeSendFailed struct {
	Peer *device.Peer
	Err  error
}

func (e *EventHandshakeSendFailed) IsErrorf() bool { return true }
func (*EventHandshakeSendFailed) Format() string   { return "%v - Failed to send handshake response: %v" }
func (e *EventHandshakeSendFailed) Args() []any    { return []any{e.Peer, e.Err} }
func (*EventHandshakeSendFailed) Nice() string     { return "Failed to send handshake response" }
func (e *EventHandshakeSendFailed) Slog(l *slog.Logger) {
	l.Error(e.Nice(), "Peer", e.Peer, "Err", e.Err)
}

var _ Event = (*EventIPv4PacketDisallowed)(nil)

type EventIPv4PacketDisallowed struct {
	Peer *device.Peer
}

func (e *EventIPv4PacketDisallowed) IsErrorf() bool { return false }
func (*EventIPv4PacketDisallowed) Format() string {
	return "IPv4 packet with disallowed source address from %v"
}
func (e *EventIPv4PacketDisallowed) Args() []any { return []any{e.Peer} }
func (*EventIPv4PacketDisallowed) Nice() string {
	return "IPv4 packet with disallowed source address from"
}
func (e *EventIPv4PacketDisallowed) Slog(l *slog.Logger) { l.Warn(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventIPv6PacketDisallowed)(nil)

type EventIPv6PacketDisallowed struct {
	Peer *device.Peer
}

func (e *EventIPv6PacketDisallowed) IsErrorf() bool { return false }
func (*EventIPv6PacketDisallowed) Format() string {
	return "IPv6 packet with disallowed source address from %v"
}
func (e *EventIPv6PacketDisallowed) Args() []any { return []any{e.Peer} }
func (*EventIPv6PacketDisallowed) Nice() string {
	return "IPv6 packet with disallowed source address from"
}
func (e *EventIPv6PacketDisallowed) Slog(l *slog.Logger) { l.Warn(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventInitiationMessageDecodeFailed)(nil)

type EventInitiationMessageDecodeFailed struct{}

func (e *EventInitiationMessageDecodeFailed) IsErrorf() bool { return true }
func (*EventInitiationMessageDecodeFailed) Format() string {
	return "Failed to decode initiation message"
}
func (e *EventInitiationMessageDecodeFailed) Args() []any         { return []any{} }
func (*EventInitiationMessageDecodeFailed) Nice() string          { return "" }
func (e *EventInitiationMessageDecodeFailed) Slog(l *slog.Logger) { l.Error(e.Nice()) }

var _ Event = (*EventInterfaceCloseIgnoreRequestedState)(nil)

type EventInterfaceCloseIgnoreRequestedState struct {
	Want fmt.Stringer
}

func (e *EventInterfaceCloseIgnoreRequestedState) IsErrorf() bool { return false }
func (*EventInterfaceCloseIgnoreRequestedState) Format() string {
	return "Interface closed, ignored requested state %s"
}
func (e *EventInterfaceCloseIgnoreRequestedState) Args() []any { return []any{e.Want} }
func (*EventInterfaceCloseIgnoreRequestedState) Nice() string {
	return "Interface closed, ignored requested state"
}
func (e *EventInterfaceCloseIgnoreRequestedState) Slog(l *slog.Logger) {
	l.Warn(e.Nice(), "Want", e.Want)
}

var _ Event = (*EventInterfaceDownRequested)(nil)

type EventInterfaceDownRequested struct{}

func (e *EventInterfaceDownRequested) IsErrorf() bool      { return false }
func (*EventInterfaceDownRequested) Format() string        { return "Interface down requested" }
func (e *EventInterfaceDownRequested) Args() []any         { return []any{} }
func (*EventInterfaceDownRequested) Nice() string          { return "" }
func (e *EventInterfaceDownRequested) Slog(l *slog.Logger) { l.Debug(e.Nice()) }

var _ Event = (*EventInterfaceStateChanged)(nil)

type EventInterfaceStateChanged struct {
	Old  fmt.Stringer
	Want fmt.Stringer
	Now  fmt.Stringer
}

func (e *EventInterfaceStateChanged) IsErrorf() bool { return false }
func (*EventInterfaceStateChanged) Format() string {
	return "Interface state was %s, requested %s, now %s"
}
func (e *EventInterfaceStateChanged) Args() []any { return []any{e.Old, e.Want, e.Now} }
func (*EventInterfaceStateChanged) Nice() string  { return "Interface state changed" }
func (e *EventInterfaceStateChanged) Slog(l *slog.Logger) {
	l.Info(e.Nice(), "Old", e.Old, "Want", e.Want, "Now", e.Now)
}

var _ Event = (*EventInterfaceUpRequested)(nil)

type EventInterfaceUpRequested struct{}

func (e *EventInterfaceUpRequested) IsErrorf() bool      { return false }
func (*EventInterfaceUpRequested) Format() string        { return "Interface up requested" }
func (e *EventInterfaceUpRequested) Args() []any         { return []any{} }
func (*EventInterfaceUpRequested) Nice() string          { return "" }
func (e *EventInterfaceUpRequested) Slog(l *slog.Logger) { l.Debug(e.Nice()) }

var _ Event = (*EventInvalidMAC1)(nil)

type EventInvalidMAC1 struct{}

func (e *EventInvalidMAC1) IsErrorf() bool      { return false }
func (*EventInvalidMAC1) Format() string        { return "Received packet with invalid mac1" }
func (e *EventInvalidMAC1) Args() []any         { return []any{} }
func (*EventInvalidMAC1) Nice() string          { return "" }
func (e *EventInvalidMAC1) Slog(l *slog.Logger) { l.Warn(e.Nice()) }

var _ Event = (*EventInvalidOperation)(nil)

type EventInvalidOperation struct {
	Op string
}

func (e *EventInvalidOperation) IsErrorf() bool      { return true }
func (*EventInvalidOperation) Format() string        { return "invalid UAPI operation: %v" }
func (e *EventInvalidOperation) Args() []any         { return []any{e.Op} }
func (*EventInvalidOperation) Nice() string          { return "invalid UAPI operation" }
func (e *EventInvalidOperation) Slog(l *slog.Logger) { l.Error(e.Nice(), "Op", e.Op) }

var _ Event = (*EventInvalidPacketInHandshakeQueue)(nil)

type EventInvalidPacketInHandshakeQueue struct{}

func (e *EventInvalidPacketInHandshakeQueue) IsErrorf() bool { return true }
func (*EventInvalidPacketInHandshakeQueue) Format() string {
	return "Invalid packet ended up in the handshake queue"
}
func (e *EventInvalidPacketInHandshakeQueue) Args() []any         { return []any{} }
func (*EventInvalidPacketInHandshakeQueue) Nice() string          { return "" }
func (e *EventInvalidPacketInHandshakeQueue) Slog(l *slog.Logger) { l.Error(e.Nice()) }

var _ Event = (*EventLoadMTUFailed)(nil)

type EventLoadMTUFailed struct {
	Err error
}

func (e *EventLoadMTUFailed) IsErrorf() bool      { return true }
func (*EventLoadMTUFailed) Format() string        { return "Failed to load updated MTU of device: %v" }
func (e *EventLoadMTUFailed) Args() []any         { return []any{e.Err} }
func (*EventLoadMTUFailed) Nice() string          { return "Failed to load updated MTU of device" }
func (e *EventLoadMTUFailed) Slog(l *slog.Logger) { l.Error(e.Nice(), "Err", e.Err) }

var _ Event = (*EventMTUTooLarge)(nil)

type EventMTUTooLarge struct {
	MTU int
	Cap int
}

func (e *EventMTUTooLarge) IsErrorf() bool      { return false }
func (*EventMTUTooLarge) Format() string        { return "MTU updated: %v (too large, capped at %v)" }
func (e *EventMTUTooLarge) Args() []any         { return []any{e.MTU, e.Cap} }
func (*EventMTUTooLarge) Nice() string          { return "MTU too large, capped" }
func (e *EventMTUTooLarge) Slog(l *slog.Logger) { l.Warn(e.Nice(), "MTU", e.MTU, "Cap", e.Cap) }

var _ Event = (*EventMTUUpdated)(nil)

type EventMTUUpdated struct {
	MTU int
}

func (e *EventMTUUpdated) IsErrorf() bool      { return false }
func (*EventMTUUpdated) Format() string        { return "MTU updated: %v" }
func (e *EventMTUUpdated) Args() []any         { return []any{e.MTU} }
func (*EventMTUUpdated) Nice() string          { return "MTU updated" }
func (e *EventMTUUpdated) Slog(l *slog.Logger) { l.Info(e.Nice(), "MTU", e.MTU) }

var _ Event = (*EventMessageUnknownType)(nil)

type EventMessageUnknownType struct{}

func (e *EventMessageUnknownType) IsErrorf() bool      { return false }
func (*EventMessageUnknownType) Format() string        { return "Received message with unknown type" }
func (e *EventMessageUnknownType) Args() []any         { return []any{} }
func (*EventMessageUnknownType) Nice() string          { return "" }
func (e *EventMessageUnknownType) Slog(l *slog.Logger) { l.Warn(e.Nice()) }

var _ Event = (*EventNegativeMTU)(nil)

type EventNegativeMTU struct {
	MTU int
}

func (e *EventNegativeMTU) IsErrorf() bool      { return true }
func (*EventNegativeMTU) Format() string        { return "MTU not updated to negative value: %v" }
func (e *EventNegativeMTU) Args() []any         { return []any{e.MTU} }
func (*EventNegativeMTU) Nice() string          { return "MTU not updated to negative value" }
func (e *EventNegativeMTU) Slog(l *slog.Logger) { l.Error(e.Nice(), "MTU", e.MTU) }

var _ Event = (*EventPacketDataSendFailed)(nil)

type EventPacketDataSendFailed struct {
	Peer *device.Peer
	Err  error
}

func (e *EventPacketDataSendFailed) IsErrorf() bool { return true }
func (*EventPacketDataSendFailed) Format() string   { return "%v - Failed to send data packets: %v" }
func (e *EventPacketDataSendFailed) Args() []any    { return []any{e.Peer, e.Err} }
func (*EventPacketDataSendFailed) Nice() string     { return "Failed to send data packets" }
func (e *EventPacketDataSendFailed) Slog(l *slog.Logger) {
	l.Error(e.Nice(), "Peer", e.Peer, "Err", e.Err)
}

var _ Event = (*EventPacketIPVersionInvalid)(nil)

type EventPacketIPVersionInvalid struct {
	Peer *device.Peer
}

func (e *EventPacketIPVersionInvalid) IsErrorf() bool      { return false }
func (*EventPacketIPVersionInvalid) Format() string        { return "Packet with invalid IP version from %v" }
func (e *EventPacketIPVersionInvalid) Args() []any         { return []any{e.Peer} }
func (*EventPacketIPVersionInvalid) Nice() string          { return "Packet with invalid IP version from" }
func (e *EventPacketIPVersionInvalid) Slog(l *slog.Logger) { l.Warn(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventPacketIPVersionUnknown)(nil)

type EventPacketIPVersionUnknown struct{}

func (e *EventPacketIPVersionUnknown) IsErrorf() bool      { return false }
func (*EventPacketIPVersionUnknown) Format() string        { return "Received packet with unknown IP version" }
func (e *EventPacketIPVersionUnknown) Args() []any         { return []any{} }
func (*EventPacketIPVersionUnknown) Nice() string          { return "" }
func (e *EventPacketIPVersionUnknown) Slog(l *slog.Logger) { l.Debug(e.Nice()) }

var _ Event = (*EventPacketReceiveFailed)(nil)

type EventPacketReceiveFailed struct {
	RecvName string
	Err      error
}

func (e *EventPacketReceiveFailed) IsErrorf() bool { return false }
func (*EventPacketReceiveFailed) Format() string   { return "Failed to receive %s packet: %v" }
func (e *EventPacketReceiveFailed) Args() []any    { return []any{e.RecvName, e.Err} }
func (*EventPacketReceiveFailed) Nice() string     { return "Failed to receive packet" }
func (e *EventPacketReceiveFailed) Slog(l *slog.Logger) {
	l.Error(e.Nice(), "RecvName", e.RecvName, "Err", e.Err)
}

var _ Event = (*EventPeerStarting)(nil)

type EventPeerStarting struct {
	Peer *device.Peer
}

func (e *EventPeerStarting) IsErrorf() bool      { return false }
func (*EventPeerStarting) Format() string        { return "%v - Starting" }
func (e *EventPeerStarting) Args() []any         { return []any{e.Peer} }
func (*EventPeerStarting) Nice() string          { return "Starting" }
func (e *EventPeerStarting) Slog(l *slog.Logger) { l.Debug(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventPeerStopping)(nil)

type EventPeerStopping struct {
	Peer *device.Peer
}

func (e *EventPeerStopping) IsErrorf() bool      { return false }
func (*EventPeerStopping) Format() string        { return "%v - Stopping" }
func (e *EventPeerStopping) Args() []any         { return []any{e.Peer} }
func (*EventPeerStopping) Nice() string          { return "Stopping" }
func (e *EventPeerStopping) Slog(l *slog.Logger) { l.Debug(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventReceivedHandshakeInitiation)(nil)

type EventReceivedHandshakeInitiation struct {
	Peer *device.Peer
}

func (e *EventReceivedHandshakeInitiation) IsErrorf() bool      { return false }
func (*EventReceivedHandshakeInitiation) Format() string        { return "%v - Received handshake initiation" }
func (e *EventReceivedHandshakeInitiation) Args() []any         { return []any{e.Peer} }
func (*EventReceivedHandshakeInitiation) Nice() string          { return "Received handshake initiation" }
func (e *EventReceivedHandshakeInitiation) Slog(l *slog.Logger) { l.Debug(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventReceivedHandshakeResponse)(nil)

type EventReceivedHandshakeResponse struct {
	Peer *device.Peer
}

func (e *EventReceivedHandshakeResponse) IsErrorf() bool      { return false }
func (*EventReceivedHandshakeResponse) Format() string        { return "%v - Received handshake response" }
func (e *EventReceivedHandshakeResponse) Args() []any         { return []any{e.Peer} }
func (*EventReceivedHandshakeResponse) Nice() string          { return "Received handshake response" }
func (e *EventReceivedHandshakeResponse) Slog(l *slog.Logger) { l.Debug(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventReceivedInvalidInitiation)(nil)

type EventReceivedInvalidInitiation struct {
	Destination string
}

func (e *EventReceivedInvalidInitiation) IsErrorf() bool { return false }
func (*EventReceivedInvalidInitiation) Format() string {
	return "Received invalid initiation message from %s"
}
func (e *EventReceivedInvalidInitiation) Args() []any { return []any{e.Destination} }
func (*EventReceivedInvalidInitiation) Nice() string  { return "Received invalid initiation message" }
func (e *EventReceivedInvalidInitiation) Slog(l *slog.Logger) {
	l.Warn(e.Nice(), "Destination", e.Destination)
}

var _ Event = (*EventReceivedInvalidResponse)(nil)

type EventReceivedInvalidResponse struct {
	Destination string
}

func (e *EventReceivedInvalidResponse) IsErrorf() bool { return false }
func (*EventReceivedInvalidResponse) Format() string {
	return "Received invalid response message from %s"
}
func (e *EventReceivedInvalidResponse) Args() []any { return []any{e.Destination} }
func (*EventReceivedInvalidResponse) Nice() string  { return "Received invalid response message" }
func (e *EventReceivedInvalidResponse) Slog(l *slog.Logger) {
	l.Warn(e.Nice(), "Destination", e.Destination)
}

var _ Event = (*EventReceivingCookieResponse)(nil)

type EventReceivingCookieResponse struct {
	Destination string
}

func (e *EventReceivingCookieResponse) IsErrorf() bool { return false }
func (*EventReceivingCookieResponse) Format() string   { return "Receiving cookie response from %s" }
func (e *EventReceivingCookieResponse) Args() []any    { return []any{e.Destination} }
func (*EventReceivingCookieResponse) Nice() string     { return "Receiving cookie response" }
func (e *EventReceivingCookieResponse) Slog(l *slog.Logger) {
	l.Debug(e.Nice(), "Destination", e.Destination)
}

var _ Event = (*EventReceivingKeepalivePacket)(nil)

type EventReceivingKeepalivePacket struct {
	Peer *device.Peer
}

func (e *EventReceivingKeepalivePacket) IsErrorf() bool      { return false }
func (*EventReceivingKeepalivePacket) Format() string        { return "%v - Receiving keepalive packet" }
func (e *EventReceivingKeepalivePacket) Args() []any         { return []any{e.Peer} }
func (*EventReceivingKeepalivePacket) Nice() string          { return "Receiving keepalive packet" }
func (e *EventReceivingKeepalivePacket) Slog(l *slog.Logger) { l.Debug(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventRemovingAllKeys)(nil)

type EventRemovingAllKeys struct {
	Peer    *device.Peer
	Timeout int
}

func (e *EventRemovingAllKeys) IsErrorf() bool { return false }
func (*EventRemovingAllKeys) Format() string {
	return "%s - Removing all keys, since we haven't received a new one in %d seconds"
}
func (e *EventRemovingAllKeys) Args() []any { return []any{e.Peer, e.Timeout} }
func (*EventRemovingAllKeys) Nice() string {
	return "Removing all keys, since we haven't received a new one"
}
func (e *EventRemovingAllKeys) Slog(l *slog.Logger) {
	l.Debug(e.Nice(), "Peer", e.Peer, "Timeout", e.Timeout)
}

var _ Event = (*EventResponseMessageDecodeFailed)(nil)

type EventResponseMessageDecodeFailed struct{}

func (e *EventResponseMessageDecodeFailed) IsErrorf() bool      { return true }
func (*EventResponseMessageDecodeFailed) Format() string        { return "Failed to decode response message" }
func (e *EventResponseMessageDecodeFailed) Args() []any         { return []any{} }
func (*EventResponseMessageDecodeFailed) Nice() string          { return "" }
func (e *EventResponseMessageDecodeFailed) Slog(l *slog.Logger) { l.Error(e.Nice()) }

var _ Event = (*EventRetryingHandshake)(nil)

type EventRetryingHandshake struct {
	Peer    *device.Peer
	Timeout int
	Try     uint32
}

func (e *EventRetryingHandshake) IsErrorf() bool { return false }
func (*EventRetryingHandshake) Format() string {
	return "%s - Handshake did not complete after %d seconds, retrying (try %d)"
}
func (e *EventRetryingHandshake) Args() []any { return []any{e.Peer, e.Timeout, e.Try} }
func (*EventRetryingHandshake) Nice() string  { return "Handshake did not complete, retrying" }
func (e *EventRetryingHandshake) Slog(l *slog.Logger) {
	l.Warn(e.Nice(), "Peer", e.Peer, "Timeout", e.Timeout, "Try", e.Try)
}

var _ Event = (*EventRetryingHandshakeNoResponse)(nil)

type EventRetryingHandshakeNoResponse struct {
	Peer    *device.Peer
	Timeout int
}

func (e *EventRetryingHandshakeNoResponse) IsErrorf() bool { return false }
func (*EventRetryingHandshakeNoResponse) Format() string {
	return "%s - Retrying handshake because we stopped hearing back after %d seconds"
}
func (e *EventRetryingHandshakeNoResponse) Args() []any { return []any{e.Peer, e.Timeout} }
func (*EventRetryingHandshakeNoResponse) Nice() string {
	return "Retrying handshake because we stopped hearing back"
}
func (e *EventRetryingHandshakeNoResponse) Slog(l *slog.Logger) {
	l.Debug(e.Nice(), "Peer", e.Peer, "Timeout", e.Timeout)
}

var _ Event = (*EventSendCookieDenied)(nil)

type EventSendCookieDenied struct {
	Destination string
}

func (e *EventSendCookieDenied) IsErrorf() bool { return false }
func (*EventSendCookieDenied) Format() string {
	return "Sending cookie response for denied handshake message for %v"
}
func (e *EventSendCookieDenied) Args() []any { return []any{e.Destination} }
func (*EventSendCookieDenied) Nice() string {
	return "Sending cookie response for denied handshake message"
}
func (e *EventSendCookieDenied) Slog(l *slog.Logger) { l.Warn(e.Nice(), "Destination", e.Destination) }

var _ Event = (*EventSendHandshakeInitiationFailed)(nil)

type EventSendHandshakeInitiationFailed struct {
	Peer *device.Peer
	Err  error
}

func (e *EventSendHandshakeInitiationFailed) IsErrorf() bool { return true }
func (*EventSendHandshakeInitiationFailed) Format() string {
	return "%v - Failed to send handshake initiation: %v"
}
func (e *EventSendHandshakeInitiationFailed) Args() []any { return []any{e.Peer, e.Err} }
func (*EventSendHandshakeInitiationFailed) Nice() string {
	return "Failed to send handshake initiation"
}
func (e *EventSendHandshakeInitiationFailed) Slog(l *slog.Logger) {
	l.Error(e.Nice(), "Peer", e.Peer, "Err", e.Err)
}

var _ Event = (*EventSendingHandshakeInitiation)(nil)

type EventSendingHandshakeInitiation struct {
	Peer *device.Peer
}

func (e *EventSendingHandshakeInitiation) IsErrorf() bool      { return false }
func (*EventSendingHandshakeInitiation) Format() string        { return "%v - Sending handshake initiation" }
func (e *EventSendingHandshakeInitiation) Args() []any         { return []any{e.Peer} }
func (*EventSendingHandshakeInitiation) Nice() string          { return "Sending handshake initiation" }
func (e *EventSendingHandshakeInitiation) Slog(l *slog.Logger) { l.Debug(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventSendingHandshakeResponse)(nil)

type EventSendingHandshakeResponse struct {
	Peer *device.Peer
}

func (e *EventSendingHandshakeResponse) IsErrorf() bool      { return false }
func (*EventSendingHandshakeResponse) Format() string        { return "%v - Sending handshake response" }
func (e *EventSendingHandshakeResponse) Args() []any         { return []any{e.Peer} }
func (*EventSendingHandshakeResponse) Nice() string          { return "Sending handshake response" }
func (e *EventSendingHandshakeResponse) Slog(l *slog.Logger) { l.Debug(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventSendingKeepalivePacket)(nil)

type EventSendingKeepalivePacket struct {
	Peer *device.Peer
}

func (e *EventSendingKeepalivePacket) IsErrorf() bool      { return false }
func (*EventSendingKeepalivePacket) Format() string        { return "%v - Sending keepalive packet" }
func (e *EventSendingKeepalivePacket) Args() []any         { return []any{e.Peer} }
func (*EventSendingKeepalivePacket) Nice() string          { return "Sending keepalive packet" }
func (e *EventSendingKeepalivePacket) Slog(l *slog.Logger) { l.Debug(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventSequentialReaderStopped)(nil)

type EventSequentialReaderStopped struct {
	Peer *device.Peer
}

func (e *EventSequentialReaderStopped) IsErrorf() bool { return false }
func (*EventSequentialReaderStopped) Format() string {
	return "%v - Routine: sequential sender - stopped"
}
func (e *EventSequentialReaderStopped) Args() []any         { return []any{e.Peer} }
func (*EventSequentialReaderStopped) Nice() string          { return "Routine: sequential sender - stopped" }
func (e *EventSequentialReaderStopped) Slog(l *slog.Logger) { l.Debug(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventSequentialReceiverStarted)(nil)

type EventSequentialReceiverStarted struct {
	Peer *device.Peer
}

func (e *EventSequentialReceiverStarted) IsErrorf() bool { return false }
func (*EventSequentialReceiverStarted) Format() string {
	return "%v - Routine: sequential receiver - started"
}
func (e *EventSequentialReceiverStarted) Args() []any         { return []any{e.Peer} }
func (*EventSequentialReceiverStarted) Nice() string          { return "Routine: sequential receiver - started" }
func (e *EventSequentialReceiverStarted) Slog(l *slog.Logger) { l.Debug(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventSequentialReceiverStopped)(nil)

type EventSequentialReceiverStopped struct {
	Peer *device.Peer
}

func (e *EventSequentialReceiverStopped) IsErrorf() bool { return false }
func (*EventSequentialReceiverStopped) Format() string {
	return "%v - Routine: sequential receiver - stopped"
}
func (e *EventSequentialReceiverStopped) Args() []any         { return []any{e.Peer} }
func (*EventSequentialReceiverStopped) Nice() string          { return "Routine: sequential receiver - stopped" }
func (e *EventSequentialReceiverStopped) Slog(l *slog.Logger) { l.Debug(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventSequentialSenderStarted)(nil)

type EventSequentialSenderStarted struct {
	Peer *device.Peer
}

func (e *EventSequentialSenderStarted) IsErrorf() bool { return false }
func (*EventSequentialSenderStarted) Format() string {
	return "%v - Routine: sequential sender - started"
}
func (e *EventSequentialSenderStarted) Args() []any         { return []any{e.Peer} }
func (*EventSequentialSenderStarted) Nice() string          { return "Routine: sequential sender - started" }
func (e *EventSequentialSenderStarted) Slog(l *slog.Logger) { l.Debug(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventStartedDecryptionWorker)(nil)

type EventStartedDecryptionWorker struct {
	ID int
}

func (e *EventStartedDecryptionWorker) IsErrorf() bool { return false }
func (*EventStartedDecryptionWorker) Format() string {
	return "Routine: decryption worker %d - started"
}
func (e *EventStartedDecryptionWorker) Args() []any         { return []any{e.ID} }
func (*EventStartedDecryptionWorker) Nice() string          { return "Routine: decryption worker started" }
func (e *EventStartedDecryptionWorker) Slog(l *slog.Logger) { l.Debug(e.Nice(), "ID", e.ID) }

var _ Event = (*EventStartedEncryptionWorker)(nil)

type EventStartedEncryptionWorker struct {
	ID int
}

func (e *EventStartedEncryptionWorker) IsErrorf() bool { return false }
func (*EventStartedEncryptionWorker) Format() string {
	return "Routine: encryption worker %d - started"
}
func (e *EventStartedEncryptionWorker) Args() []any         { return []any{e.ID} }
func (*EventStartedEncryptionWorker) Nice() string          { return "Routine: encryption worker started" }
func (e *EventStartedEncryptionWorker) Slog(l *slog.Logger) { l.Debug(e.Nice(), "ID", e.ID) }

var _ Event = (*EventStartedHandshakeWorker)(nil)

type EventStartedHandshakeWorker struct {
	ID int
}

func (e *EventStartedHandshakeWorker) IsErrorf() bool      { return false }
func (*EventStartedHandshakeWorker) Format() string        { return "Routine: handshake worker %d - started" }
func (e *EventStartedHandshakeWorker) Args() []any         { return []any{e.ID} }
func (*EventStartedHandshakeWorker) Nice() string          { return "Routine: handshake worker started" }
func (e *EventStartedHandshakeWorker) Slog(l *slog.Logger) { l.Debug(e.Nice(), "ID", e.ID) }

var _ Event = (*EventStartedReceivingIncoming)(nil)

type EventStartedReceivingIncoming struct {
	RecvName string
}

func (e *EventStartedReceivingIncoming) IsErrorf() bool { return false }
func (*EventStartedReceivingIncoming) Format() string {
	return "Routine: receive incoming %s - stopped"
}
func (e *EventStartedReceivingIncoming) Args() []any { return []any{e.RecvName} }
func (*EventStartedReceivingIncoming) Nice() string  { return "Routine: receive incoming stopped" }
func (e *EventStartedReceivingIncoming) Slog(l *slog.Logger) {
	l.Debug(e.Nice(), "RecvName", e.RecvName)
}

var _ Event = (*EventStoppedEncryptionWorker)(nil)

type EventStoppedEncryptionWorker struct {
	ID int
}

func (e *EventStoppedEncryptionWorker) IsErrorf() bool { return false }
func (*EventStoppedEncryptionWorker) Format() string {
	return "Routine: encryption worker %d - stopped"
}
func (e *EventStoppedEncryptionWorker) Args() []any         { return []any{e.ID} }
func (*EventStoppedEncryptionWorker) Nice() string          { return "Routine: encryption worker stopped" }
func (e *EventStoppedEncryptionWorker) Slog(l *slog.Logger) { l.Debug(e.Nice(), "ID", e.ID) }

var _ Event = (*EventStoppedHandshakeWorker)(nil)

type EventStoppedHandshakeWorker struct {
	ID int
}

func (e *EventStoppedHandshakeWorker) IsErrorf() bool      { return false }
func (*EventStoppedHandshakeWorker) Format() string        { return "Routine: handshake worker %d - stopped" }
func (e *EventStoppedHandshakeWorker) Args() []any         { return []any{e.ID} }
func (*EventStoppedHandshakeWorker) Nice() string          { return "Routine: handshake worker stopped" }
func (e *EventStoppedHandshakeWorker) Slog(l *slog.Logger) { l.Debug(e.Nice(), "ID", e.ID) }

var _ Event = (*EventStoppedReceivingIncoming)(nil)

type EventStoppedReceivingIncoming struct {
	RecvName string
}

func (e *EventStoppedReceivingIncoming) IsErrorf() bool { return false }
func (*EventStoppedReceivingIncoming) Format() string {
	return "Routine: receive incoming %s - started"
}
func (e *EventStoppedReceivingIncoming) Args() []any { return []any{e.RecvName} }
func (*EventStoppedReceivingIncoming) Nice() string  { return "Routine: receive incoming started" }
func (e *EventStoppedReceivingIncoming) Slog(l *slog.Logger) {
	l.Debug(e.Nice(), "RecvName", e.RecvName)
}

var _ Event = (*EventTUNReaderStarted)(nil)

type EventTUNReaderStarted struct{}

func (e *EventTUNReaderStarted) IsErrorf() bool      { return false }
func (*EventTUNReaderStarted) Format() string        { return "Routine: TUN reader - started" }
func (e *EventTUNReaderStarted) Args() []any         { return []any{} }
func (*EventTUNReaderStarted) Nice() string          { return "" }
func (e *EventTUNReaderStarted) Slog(l *slog.Logger) { l.Debug(e.Nice()) }

var _ Event = (*EventTUNReaderStopped)(nil)

type EventTUNReaderStopped struct{}

func (e *EventTUNReaderStopped) IsErrorf() bool      { return false }
func (*EventTUNReaderStopped) Format() string        { return "Routine: TUN reader - stopped" }
func (e *EventTUNReaderStopped) Args() []any         { return []any{} }
func (*EventTUNReaderStopped) Nice() string          { return "" }
func (e *EventTUNReaderStopped) Slog(l *slog.Logger) { l.Debug(e.Nice()) }

var _ Event = (*EventTUNWriteFailed)(nil)

type EventTUNWriteFailed struct {
	Err error
}

func (e *EventTUNWriteFailed) IsErrorf() bool      { return true }
func (*EventTUNWriteFailed) Format() string        { return "Failed to write packets to TUN device: %v" }
func (e *EventTUNWriteFailed) Args() []any         { return []any{e.Err} }
func (*EventTUNWriteFailed) Nice() string          { return "Failed to write packets to TUN device" }
func (e *EventTUNWriteFailed) Slog(l *slog.Logger) { l.Error(e.Nice(), "Err", e.Err) }

var _ Event = (*EventTunPacketReadFailed)(nil)

type EventTunPacketReadFailed struct {
	Err error
}

func (e *EventTunPacketReadFailed) IsErrorf() bool      { return true }
func (*EventTunPacketReadFailed) Format() string        { return "Failed to read packet from TUN device: %v" }
func (e *EventTunPacketReadFailed) Args() []any         { return []any{e.Err} }
func (*EventTunPacketReadFailed) Nice() string          { return "Failed to read packet from TUN device" }
func (e *EventTunPacketReadFailed) Slog(l *slog.Logger) { l.Error(e.Nice(), "Err", e.Err) }

var _ Event = (*EventUAPIAddingAllowedIP)(nil)

type EventUAPIAddingAllowedIP struct {
	Peer *device.Peer
}

func (e *EventUAPIAddingAllowedIP) IsErrorf() bool      { return false }
func (*EventUAPIAddingAllowedIP) Format() string        { return "%v - UAPI: Adding allowedip" }
func (e *EventUAPIAddingAllowedIP) Args() []any         { return []any{e.Peer} }
func (*EventUAPIAddingAllowedIP) Nice() string          { return "UAPI: Adding allowedip" }
func (e *EventUAPIAddingAllowedIP) Slog(l *slog.Logger) { l.Debug(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventUAPICreated)(nil)

type EventUAPICreated struct {
	Peer *device.Peer
}

func (e *EventUAPICreated) IsErrorf() bool      { return false }
func (*EventUAPICreated) Format() string        { return "%v - UAPI: Created" }
func (e *EventUAPICreated) Args() []any         { return []any{e.Peer} }
func (*EventUAPICreated) Nice() string          { return "UAPI: Created" }
func (e *EventUAPICreated) Slog(l *slog.Logger) { l.Debug(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventUAPIRemovingAllAllowedIPs)(nil)

type EventUAPIRemovingAllAllowedIPs struct {
	Peer *device.Peer
}

func (e *EventUAPIRemovingAllAllowedIPs) IsErrorf() bool      { return false }
func (*EventUAPIRemovingAllAllowedIPs) Format() string        { return "%v - UAPI: Removing all allowedips" }
func (e *EventUAPIRemovingAllAllowedIPs) Args() []any         { return []any{e.Peer} }
func (*EventUAPIRemovingAllAllowedIPs) Nice() string          { return "UAPI: Removing all allowedips" }
func (e *EventUAPIRemovingAllAllowedIPs) Slog(l *slog.Logger) { l.Debug(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventUAPIRemovingAllPeers)(nil)

type EventUAPIRemovingAllPeers struct{}

func (e *EventUAPIRemovingAllPeers) IsErrorf() bool      { return false }
func (*EventUAPIRemovingAllPeers) Format() string        { return "UAPI: Removing all peers" }
func (e *EventUAPIRemovingAllPeers) Args() []any         { return []any{} }
func (*EventUAPIRemovingAllPeers) Nice() string          { return "" }
func (e *EventUAPIRemovingAllPeers) Slog(l *slog.Logger) { l.Debug(e.Nice()) }

var _ Event = (*EventUAPIRemovingPeer)(nil)

type EventUAPIRemovingPeer struct {
	Peer *device.Peer
}

func (e *EventUAPIRemovingPeer) IsErrorf() bool      { return false }
func (*EventUAPIRemovingPeer) Format() string        { return "%v - UAPI: Removing" }
func (e *EventUAPIRemovingPeer) Args() []any         { return []any{e.Peer} }
func (*EventUAPIRemovingPeer) Nice() string          { return "UAPI: Removing" }
func (e *EventUAPIRemovingPeer) Slog(l *slog.Logger) { l.Debug(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventUAPIUpdatingEndpoint)(nil)

type EventUAPIUpdatingEndpoint struct {
	Peer *device.Peer
}

func (e *EventUAPIUpdatingEndpoint) IsErrorf() bool      { return false }
func (*EventUAPIUpdatingEndpoint) Format() string        { return "%v - UAPI: Updating endpoint" }
func (e *EventUAPIUpdatingEndpoint) Args() []any         { return []any{e.Peer} }
func (*EventUAPIUpdatingEndpoint) Nice() string          { return "UAPI: Updating endpoint" }
func (e *EventUAPIUpdatingEndpoint) Slog(l *slog.Logger) { l.Debug(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventUAPIUpdatingFWMark)(nil)

type EventUAPIUpdatingFWMark struct{}

func (e *EventUAPIUpdatingFWMark) IsErrorf() bool      { return false }
func (*EventUAPIUpdatingFWMark) Format() string        { return "UAPI: Updating fwmark" }
func (e *EventUAPIUpdatingFWMark) Args() []any         { return []any{} }
func (*EventUAPIUpdatingFWMark) Nice() string          { return "" }
func (e *EventUAPIUpdatingFWMark) Slog(l *slog.Logger) { l.Debug(e.Nice()) }

var _ Event = (*EventUAPIUpdatingListenPort)(nil)

type EventUAPIUpdatingListenPort struct{}

func (e *EventUAPIUpdatingListenPort) IsErrorf() bool      { return false }
func (*EventUAPIUpdatingListenPort) Format() string        { return "UAPI: Updating listen port" }
func (e *EventUAPIUpdatingListenPort) Args() []any         { return []any{} }
func (*EventUAPIUpdatingListenPort) Nice() string          { return "" }
func (e *EventUAPIUpdatingListenPort) Slog(l *slog.Logger) { l.Debug(e.Nice()) }

var _ Event = (*EventUAPIUpdatingPersistentKeepalive)(nil)

type EventUAPIUpdatingPersistentKeepalive struct {
	Peer *device.Peer
}

func (e *EventUAPIUpdatingPersistentKeepalive) IsErrorf() bool { return false }
func (*EventUAPIUpdatingPersistentKeepalive) Format() string {
	return "%v - UAPI: Updating persistent keepalive interval"
}
func (e *EventUAPIUpdatingPersistentKeepalive) Args() []any { return []any{e.Peer} }
func (*EventUAPIUpdatingPersistentKeepalive) Nice() string {
	return "UAPI: Updating persistent keepalive interval"
}
func (e *EventUAPIUpdatingPersistentKeepalive) Slog(l *slog.Logger) {
	l.Debug(e.Nice(), "Peer", e.Peer)
}

var _ Event = (*EventUAPIUpdatingPresharedKey)(nil)

type EventUAPIUpdatingPresharedKey struct {
	Peer *device.Peer
}

func (e *EventUAPIUpdatingPresharedKey) IsErrorf() bool      { return false }
func (*EventUAPIUpdatingPresharedKey) Format() string        { return "%v - UAPI: Updating preshared key" }
func (e *EventUAPIUpdatingPresharedKey) Args() []any         { return []any{e.Peer} }
func (*EventUAPIUpdatingPresharedKey) Nice() string          { return "UAPI: Updating preshared key" }
func (e *EventUAPIUpdatingPresharedKey) Slog(l *slog.Logger) { l.Debug(e.Nice(), "Peer", e.Peer) }

var _ Event = (*EventUAPIUpdatingPrivateKey)(nil)

type EventUAPIUpdatingPrivateKey struct{}

func (e *EventUAPIUpdatingPrivateKey) IsErrorf() bool      { return false }
func (*EventUAPIUpdatingPrivateKey) Format() string        { return "UAPI: Updating private key" }
func (e *EventUAPIUpdatingPrivateKey) Args() []any         { return []any{} }
func (*EventUAPIUpdatingPrivateKey) Nice() string          { return "" }
func (e *EventUAPIUpdatingPrivateKey) Slog(l *slog.Logger) { l.Debug(e.Nice()) }

var _ Event = (*EventUDPGSODisabled)(nil)

type EventUDPGSODisabled struct {
	OnLAddr string
}

func (e *EventUDPGSODisabled) IsErrorf() bool { return false }
func (*EventUDPGSODisabled) Format() string {
	return "disabled UDP GSO on %s, NIC(s) may not support checksum offload"
}
func (e *EventUDPGSODisabled) Args() []any { return []any{e.OnLAddr} }
func (*EventUDPGSODisabled) Nice() string {
	return "disabled UDP GSO, NIC(s) may not support checksum offload"
}
func (e *EventUDPGSODisabled) Slog(l *slog.Logger) { l.Warn(e.Nice(), "OnLAddr", e.OnLAddr) }

var _ Event = (*EventUpdateBind)(nil)

type EventUpdateBind struct {
	Err error
}

func (e *EventUpdateBind) IsErrorf() bool      { return true }
func (*EventUpdateBind) Format() string        { return "Unable to update bind: %v" }
func (e *EventUpdateBind) Args() []any         { return []any{e.Err} }
func (*EventUpdateBind) Nice() string          { return "Unable to update bind" }
func (e *EventUpdateBind) Slog(l *slog.Logger) { l.Error(e.Nice(), "Err", e.Err) }

var _ Event = (*EventValue)(nil)

type EventValue struct {
	Err error
}

func (e *EventValue) IsErrorf() bool      { return true }
func (*EventValue) Format() string        { return "%v" }
func (e *EventValue) Args() []any         { return []any{e.Err} }
func (*EventValue) Nice() string          { return "error" }
func (e *EventValue) Slog(l *slog.Logger) { l.Error(e.Nice(), "Err", e.Err) }

type EventAny struct {
	format string
	args   []any
	error  bool
}

func (e *EventAny) Format() string { return e.format }
func (e *EventAny) Args() []any    { return e.args }
func (e *EventAny) Nice() string   { return fmt.Sprintf(e.Format(), e.Args()...) }
func (e *EventAny) IsErrorf() bool { return e.error }
func (e *EventAny) Slog(l *slog.Logger) {
	if e.error {
		l.Error(e.Nice())
	} else {
		l.Debug(e.Nice())
	}
}

func Events(e chan<- Event) *device.Logger {
	return &device.Logger{
		Verbosef: func(format string, args ...any) {
			switch format {
			case "UDP bind has been updated":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventBindUpdated{}
			case "Could not decrypt invalid cookie response":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventCookieResponseInvalid{}
			case "Failed to decode cookie reply":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventDecodeCookieReplyFailed{}
			case "Routine: decryption worker %d - stopped":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(int)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventDecryptionWorkerStopped{ID: v0}
			case "Device closed":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventDeviceClosed{}
			case "Device closing":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventDeviceClosing{}
			case "Dropped some packets from multi-segment read: %v":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(error)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventDroppedPacketsFromMultiSegmentRead{Err: v0}
			case "Routine: event worker - started":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventEventWorkerStarted{}
			case "Routine: event worker - stopped":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventEventWorkerStopped{}
			case "%s - Handshake did not complete after %d attempts, giving up":
				if len(args) != 2 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v1, ok := args[1].(int)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventHandshakeDidNotComplete{Peer: v0, Attempts: v1}
			case "%v - ConsumeMessageInitiation: handshake flood":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventHandshakeFlood{Peer: v0}
			case "%v - ConsumeMessageInitiation: handshake replay @ %v":
				if len(args) != 2 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v1, ok := args[1].(tai64n.Timestamp)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventHandshakeReplay{Peer: v0, Timestamp: v1}
			case "IPv4 packet with disallowed source address from %v":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventIPv4PacketDisallowed{Peer: v0}
			case "IPv6 packet with disallowed source address from %v":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventIPv6PacketDisallowed{Peer: v0}
			case "Interface closed, ignored requested state %s":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(fmt.Stringer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventInterfaceCloseIgnoreRequestedState{Want: v0}
			case "Interface down requested":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventInterfaceDownRequested{}
			case "Interface state was %s, requested %s, now %s":
				if len(args) != 3 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(fmt.Stringer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v1, ok := args[1].(fmt.Stringer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v2, ok := args[2].(fmt.Stringer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventInterfaceStateChanged{Old: v0, Want: v1, Now: v2}
			case "Interface up requested":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventInterfaceUpRequested{}
			case "Received packet with invalid mac1":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventInvalidMAC1{}
			case "MTU updated: %v (too large, capped at %v)":
				if len(args) != 2 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(int)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v1, ok := args[1].(int)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventMTUTooLarge{MTU: v0, Cap: v1}
			case "MTU updated: %v":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(int)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventMTUUpdated{MTU: v0}
			case "Received message with unknown type":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventMessageUnknownType{}
			case "Packet with invalid IP version from %v":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventPacketIPVersionInvalid{Peer: v0}
			case "Received packet with unknown IP version":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventPacketIPVersionUnknown{}
			case "Failed to receive %s packet: %v":
				if len(args) != 2 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(string)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v1, ok := args[1].(error)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventPacketReceiveFailed{RecvName: v0, Err: v1}
			case "%v - Starting":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventPeerStarting{Peer: v0}
			case "%v - Stopping":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventPeerStopping{Peer: v0}
			case "%v - Received handshake initiation":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventReceivedHandshakeInitiation{Peer: v0}
			case "%v - Received handshake response":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventReceivedHandshakeResponse{Peer: v0}
			case "Received invalid initiation message from %s":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(string)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventReceivedInvalidInitiation{Destination: v0}
			case "Received invalid response message from %s":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(string)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventReceivedInvalidResponse{Destination: v0}
			case "Receiving cookie response from %s":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(string)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventReceivingCookieResponse{Destination: v0}
			case "%v - Receiving keepalive packet":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventReceivingKeepalivePacket{Peer: v0}
			case "%s - Removing all keys, since we haven't received a new one in %d seconds":
				if len(args) != 2 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v1, ok := args[1].(int)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventRemovingAllKeys{Peer: v0, Timeout: v1}
			case "%s - Handshake did not complete after %d seconds, retrying (try %d)":
				if len(args) != 3 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v1, ok := args[1].(int)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v2, ok := args[2].(uint32)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventRetryingHandshake{Peer: v0, Timeout: v1, Try: v2}
			case "%s - Retrying handshake because we stopped hearing back after %d seconds":
				if len(args) != 2 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v1, ok := args[1].(int)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventRetryingHandshakeNoResponse{Peer: v0, Timeout: v1}
			case "Sending cookie response for denied handshake message for %v":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(string)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventSendCookieDenied{Destination: v0}
			case "%v - Sending handshake initiation":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventSendingHandshakeInitiation{Peer: v0}
			case "%v - Sending handshake response":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventSendingHandshakeResponse{Peer: v0}
			case "%v - Sending keepalive packet":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventSendingKeepalivePacket{Peer: v0}
			case "%v - Routine: sequential sender - stopped":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventSequentialReaderStopped{Peer: v0}
			case "%v - Routine: sequential receiver - started":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventSequentialReceiverStarted{Peer: v0}
			case "%v - Routine: sequential receiver - stopped":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventSequentialReceiverStopped{Peer: v0}
			case "%v - Routine: sequential sender - started":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventSequentialSenderStarted{Peer: v0}
			case "Routine: decryption worker %d - started":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(int)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventStartedDecryptionWorker{ID: v0}
			case "Routine: encryption worker %d - started":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(int)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventStartedEncryptionWorker{ID: v0}
			case "Routine: handshake worker %d - started":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(int)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventStartedHandshakeWorker{ID: v0}
			case "Routine: receive incoming %s - stopped":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(string)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventStartedReceivingIncoming{RecvName: v0}
			case "Routine: encryption worker %d - stopped":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(int)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventStoppedEncryptionWorker{ID: v0}
			case "Routine: handshake worker %d - stopped":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(int)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventStoppedHandshakeWorker{ID: v0}
			case "Routine: receive incoming %s - started":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(string)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventStoppedReceivingIncoming{RecvName: v0}
			case "Routine: TUN reader - started":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventTUNReaderStarted{}
			case "Routine: TUN reader - stopped":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventTUNReaderStopped{}
			case "%v - UAPI: Adding allowedip":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventUAPIAddingAllowedIP{Peer: v0}
			case "%v - UAPI: Created":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventUAPICreated{Peer: v0}
			case "%v - UAPI: Removing all allowedips":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventUAPIRemovingAllAllowedIPs{Peer: v0}
			case "UAPI: Removing all peers":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventUAPIRemovingAllPeers{}
			case "%v - UAPI: Removing":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventUAPIRemovingPeer{Peer: v0}
			case "%v - UAPI: Updating endpoint":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventUAPIUpdatingEndpoint{Peer: v0}
			case "UAPI: Updating fwmark":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventUAPIUpdatingFWMark{}
			case "UAPI: Updating listen port":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventUAPIUpdatingListenPort{}
			case "%v - UAPI: Updating persistent keepalive interval":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventUAPIUpdatingPersistentKeepalive{Peer: v0}
			case "%v - UAPI: Updating preshared key":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventUAPIUpdatingPresharedKey{Peer: v0}
			case "UAPI: Updating private key":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
				e <- &EventUAPIUpdatingPrivateKey{}
			case "disabled UDP GSO on %s, NIC(s) may not support checksum offload":
				var ev EventUDPGSODisabled
				if !parser.ParseUDPGSODisabled(&ev, format, args...) {
					e <- &EventAny{format: format, args: args, error: false}
					return
				}
			default:
				e <- &EventAny{format: format, args: args, error: false}
				return
			}
		},
		Errorf: func(format string, args ...any) {
			switch format {
			case "Trouble determining MTU, assuming default: %v":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v0, ok := args[0].(error)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				e <- &EventAssumingDefaultMTU{Err: v0}
			case "Bind close failed: %v":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v0, ok := args[0].(error)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				e <- &EventBindCloseFailed{Err: v0}
			case "Failed to create cookie reply: %v":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v0, ok := args[0].(error)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				e <- &EventCreateCookieReplyFailed{Err: v0}
			case "%v - Failed to create initiation message: %v":
				if len(args) != 2 {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v1, ok := args[1].(error)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				e <- &EventCreateInitiationMessageFailed{Peer: v0, Err: v1}
			case "%v - Failed to create response message: %v":
				if len(args) != 2 {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v1, ok := args[1].(error)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				e <- &EventCreateResponseMessageFailed{Peer: v0, Err: v1}
			case "%v - Failed to derive keypair: %v":
				if len(args) != 2 {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v1, ok := args[1].(error)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				e <- &EventDeriveKeypairFailed{Peer: v0, Err: v1}
			case "%v - Failed to send handshake response: %v":
				if len(args) != 2 {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v1, ok := args[1].(error)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				e <- &EventHandshakeSendFailed{Peer: v0, Err: v1}
			case "Failed to decode initiation message":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				e <- &EventInitiationMessageDecodeFailed{}
			case "invalid UAPI operation: %v":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v0, ok := args[0].(string)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				e <- &EventInvalidOperation{Op: v0}
			case "Invalid packet ended up in the handshake queue":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				e <- &EventInvalidPacketInHandshakeQueue{}
			case "Failed to load updated MTU of device: %v":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v0, ok := args[0].(error)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				e <- &EventLoadMTUFailed{Err: v0}
			case "MTU not updated to negative value: %v":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v0, ok := args[0].(int)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				e <- &EventNegativeMTU{MTU: v0}
			case "%v - Failed to send data packets: %v":
				if len(args) != 2 {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v1, ok := args[1].(error)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				e <- &EventPacketDataSendFailed{Peer: v0, Err: v1}
			case "Failed to decode response message":
				if len(args) != 0 {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				e <- &EventResponseMessageDecodeFailed{}
			case "%v - Failed to send handshake initiation: %v":
				if len(args) != 2 {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v0, ok := args[0].(*device.Peer)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v1, ok := args[1].(error)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				e <- &EventSendHandshakeInitiationFailed{Peer: v0, Err: v1}
			case "Failed to write packets to TUN device: %v":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v0, ok := args[0].(error)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				e <- &EventTUNWriteFailed{Err: v0}
			case "Failed to read packet from TUN device: %v":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v0, ok := args[0].(error)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				e <- &EventTunPacketReadFailed{Err: v0}
			case "Unable to update bind: %v":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v0, ok := args[0].(error)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				e <- &EventUpdateBind{Err: v0}
			case "%v":
				if len(args) != 1 {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				v0, ok := args[0].(error)
				if !ok {
					e <- &EventAny{format: format, args: args, error: true}
					return
				}
				e <- &EventValue{Err: v0}
			default:
				e <- &EventAny{format: format, args: args, error: true}
				return
			}
		},
	}
}
